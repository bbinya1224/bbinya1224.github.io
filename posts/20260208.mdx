---
title: "Zustand vs Jotai vs Redux: 상태 관리 라이브러리, 뭘 써야 할까?"
description: "세 라이브러리의 철학과 구조를 비교하고, 언제 무엇을 선택하면 좋을지 정리합니다."
date: "2026-02-08"
slug: "20260208"
category: "Frontend"
tag: "React"
published: true
---

```tsx
const useStore = create((set) => ({ count: 0 }));
const countAtom = atom(0);
const counterSlice = createSlice({ name: 'counter', initialState: { count: 0 } });
```

같은 `count: 0`을 저장하는 건데, 왜 이렇게 방법이 다를까요?

프로젝트를 시작할 때마다 "상태 관리 뭐 쓰지?"라는 질문은 빠지지 않습니다.  
저는 Zustand와 Jotai를 애용하고 있습니다. 사실은.. 아직 Redux를 직접 실무에서 사용해본 적은 없지만, 여전히 많은 프로젝트에서 쓰이고 있어서 함께 비교해보고 싶었습니다.

이 글에서 각 라이브러리의 **설계 철학**, **사용법**, 그리고 **어떤 상황에 적합한지** 를 제 개인적인 관점에서 정리해보려고 합니다.

---

## 세 라이브러리의 핵심 철학

### Zustand: "Store 하나로 단순하게"

Zustand는 **Top-Down** 방식입니다.  
하나의 Store를 만들고, 컴포넌트가 필요한 상태를 구독하는 구조입니다.

```tsx
import { create } from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));

function Counter() {
  const count = useStore((state) => state.count);
  const increment = useStore((state) => state.increment);

  return <button onClick={increment}>{count}</button>;
}
```

처음 봤을 때 "이게 전부야?"라는 생각이 들었습니다. Provider도 없고, 보일러플레이트도 거의 없습니다. `create` 하나로 Store를 만들고, 컴포넌트에서 selector로 필요한 값만 꺼내 씁니다.

Provider 없이도 동작하지만, 필요한 경우에는 React Context와 조합해 특정 컴포넌트 트리 하위에서만 상태를 공유하는 "범위가 제한된 Store"를 만들 수도 있습니다. 이 유연성이 Zustand의 매력이라고 생각합니다.

Zustand의 핵심은 **selector**입니다.  
`useStore((state) => state.count)`처럼 필요한 값만 선택하면, 해당 값이 바뀔 때만 리렌더링됩니다. 전체 Store가 바뀌어도 내가 구독한 값이 같으면 렌더링이 발생하지 않습니다.

<aside data-type="info">
**Zustand v5의 주요 변경점**

v5에서는 React 18의 `useSyncExternalStore`를 네이티브로 사용하면서 번들 사이즈가 줄었습니다.  
또한 selector의 기본 동작이 변경되어, 객체를 반환하는 경우 `useShallow`를 함께 사용해야 불필요한 리렌더링을 방지할 수 있습니다.

```tsx
import { useShallow } from 'zustand/react/shallow';

// 객체를 반환할 때는 useShallow 필수
const { count, increment } = useStore(
  useShallow((state) => ({ count: state.count, increment: state.increment }))
);
```
</aside>

---

### Jotai: "Atom 단위로 쪼개서 조합"

Jotai는 **Bottom-Up** 방식입니다.  
상태를 작은 Atom 단위로 쪼개고, 이를 조합해서 복잡한 상태를 만듭니다. Recoil에서 영감을 받았지만, 훨씬 가볍고 단순합니다.

```tsx
import { atom, useAtom } from 'jotai';

const countAtom = atom(0);

function Counter() {
  const [count, setCount] = useAtom(countAtom);

  return <button onClick={() => setCount((c) => c + 1)}>{count}</button>;
}
```

`useState`랑 거의 비슷하다는 점을 느낄 수 있습니다.
하지만 둘의 차이는 **Atom이 컴포넌트 바깥에 존재한다**는 점입니다. 어떤 컴포넌트에서든 같은 Atom을 import하면 같은 상태를 공유합니다.

Jotai는 내부적으로 React Context를 활용해 상태를 전달하지만, Atom 단위로 구독을 최적화하기 때문에 Context API의 고질적인 문제인 "불필요한 전체 리렌더링" 걱정 없이 쓸 수 있습니다. 이것이 핵심입니다.

Jotai의 강점은 **파생 상태** 입니다.

```tsx
const countAtom = atom(0);
const doubleCountAtom = atom((get) => get(countAtom) * 2);

// 비동기 파생도 가능
const userAtom = atom(async (get) => {
  const id = get(userIdAtom);
  const response = await fetch(`/api/users/${id}`);
  return response.json();
});
```

`doubleCountAtom`은 `countAtom`에 의존합니다. `countAtom`이 바뀌면 `doubleCountAtom`도 자동으로 업데이트됩니다.  
이 의존 관계가 그래프 형태로 연결되면서, **변경된 Atom을 구독하는 컴포넌트만** 정확히 리렌더링됩니다.

### Redux Toolkit: "예측 가능한 단방향 흐름"

Redux는 **Flux 아키텍처** 기반입니다.  
Action을 dispatch하면, Reducer가 상태를 업데이트하고, 구독 중인 컴포넌트가 리렌더링됩니다.

```tsx
import { createSlice, configureStore } from '@reduxjs/toolkit';
import { useSelector, useDispatch } from 'react-redux';

const counterSlice = createSlice({
  name: 'counter',
  initialState: { count: 0 },
  reducers: {
    increment: (state) => { state.count += 1; },
  },
});

const store = configureStore({ reducer: { counter: counterSlice.reducer } });

function Counter() {
  const count = useSelector((state) => state.counter.count);
  const dispatch = useDispatch();

  return <button onClick={() => dispatch(counterSlice.actions.increment())}>{count}</button>;
}
```

셋 중 가장 코드가 많습니다. 하지만 단순히 코드가 많은 게 아니라, 대규모 팀에서 "누가 짜도 똑같은 구조"가 나오게 만드는 엄격한 가이드라인을 제공하는 것이 Redux의 의도입니다.
**모든 상태 변경이 Action으로 기록**되기 때문에 DevTools에서 디버깅이 가능하고, 상태 흐름을 완전히 추적할 수 있습니다.

<aside data-type="info">
**RTK 2.10+ 성능 개선**

Redux Toolkit 2.10 이상에서는 Immer 11과 함께 스크립팅 시간이 약 30% 감소했습니다. "Redux는 느리다"는 인식은 이제 과거의 이야기입니다.
</aside>

---

## 구조 비교: 같은 기능, 다른 접근

Todo 앱의 상태 관리를 세 가지 방식으로 비교해보겠습니다.

### Zustand: 하나의 Store에 모든 것

```tsx
const useTodoStore = create((set) => ({
  todos: [],
  filter: 'all',

  addTodo: (text) =>
    set((state) => ({
      todos: [...state.todos, { id: Date.now(), text, completed: false }],
    })),

  toggleTodo: (id) =>
    set((state) => ({
      todos: state.todos.map((todo) =>
        todo.id === id ? { ...todo, completed: !todo.completed } : todo
      ),
    })),

  setFilter: (filter) => set({ filter }),
}));

// 컴포넌트에서 필요한 것만 구독
function TodoList() {
  const todos = useTodoStore((state) => state.todos);
  const filter = useTodoStore((state) => state.filter);

  const filtered = todos.filter((todo) =>
    filter === 'all' ? true : filter === 'done' ? todo.completed : !todo.completed
  );

  return filtered.map((todo) => <TodoItem key={todo.id} todo={todo} />);
}
```

상태와 액션이 한 곳에 모여 있어서 코드를 파악하기 쉽습니다. 파일 하나면 충분합니다.

### Jotai: Atom으로 분리

```tsx
const todosAtom = atom([]);
const filterAtom = atom('all');

// 파생 Atom으로 필터링 로직 분리
const filteredTodosAtom = atom((get) => {
  const todos = get(todosAtom);
  const filter = get(filterAtom);

  if (filter === 'all') return todos;
  if (filter === 'done') return todos.filter((t) => t.completed);
  return todos.filter((t) => !t.completed);
});

function TodoList() {
  const filtered = useAtomValue(filteredTodosAtom);

  return filtered.map((todo) => <TodoItem key={todo.id} todo={todo} />);
}

function FilterButtons() {
  const [filter, setFilter] = useAtom(filterAtom);

  return (
    <div>
      {['all', 'done', 'active'].map((f) => (
        <button key={f} onClick={() => setFilter(f)} data-active={filter === f}>
          {f}
        </button>
      ))}
    </div>
  );
}
```

`FilterButtons`는 `filterAtom`만 구독합니다. Todo를 추가해도 이 컴포넌트는 리렌더링되지 않습니다.  
Atom 단위로 구독이 나뉘기 때문에 **렌더링 최적화가 자연스럽게 따라옵니다.**

### Redux Toolkit — Slice + Selector

```tsx
const todoSlice = createSlice({
  name: 'todos',
  initialState: { items: [], filter: 'all' },
  reducers: {
    addTodo: (state, action) => {
      state.items.push({ id: Date.now(), text: action.payload, completed: false });
    },
    toggleTodo: (state, action) => {
      const todo = state.items.find((t) => t.id === action.payload);
      if (todo) todo.completed = !todo.completed;
    },
    setFilter: (state, action) => {
      state.filter = action.payload;
    },
  },
});

// Memoized selector
const selectFilteredTodos = createSelector(
  [(state) => state.todos.items, (state) => state.todos.filter],
  (items, filter) => {
    if (filter === 'all') return items;
    if (filter === 'done') return items.filter((t) => t.completed);
    return items.filter((t) => !t.completed);
  }
);
```

Immer 덕분에 `state.items.push()`같은 mutable한 코드를 쓸 수 있습니다. 실제로는 immutable하게 처리됩니다. `createSelector`로 메모이제이션된 파생 상태도 만들 수 있지만, Jotai의 파생 Atom에 비하면 코드량이 많습니다.

---

## 미들웨어와 확장성

### Zustand 그리고 미들웨어의 조합

```tsx
const useStore = create(
  devtools(
    persist(
      immer((set) => ({
        count: 0,
        increment: () => set((state) => { state.count += 1; }),
      })),
      { name: 'my-store' }
    )
  )
);
```

`devtools`, `persist`, `immer` 등을 함수 조합으로 감싸는 방식입니다. 필요한 것만 골라서 쓸 수 있습니다.

### Jotai 그리고 Atom 유틸리티

```tsx
import { atomWithStorage } from 'jotai/utils';

// localStorage 자동 동기화
const themeAtom = atomWithStorage('theme', 'light');

// Atom에 디버깅 레이블
countAtom.debugLabel = 'count';
```

미들웨어라기보다 **특수 목적 Atom** 을 사용합니다.  
`atomWithStorage`, `atomWithReset` 등 필요한 동작이 내장된 Atom을 골라 쓰는 방식입니다.

### Redux Toolkit, 내장 미들웨어 + RTK Query

```tsx
const store = configureStore({
  reducer: { todos: todoSlice.reducer, [api.reducerPath]: api.reducer },
  middleware: (getDefault) => getDefault().concat(api.middleware),
});
```

Redux의 가장 큰 차별점은 **RTK Query** 입니다.  
서버 상태 관리(데이터 패칭, 캐싱, 백그라운드 싱크)까지 하나의 생태계 안에서 해결할 수 있습니다.  
물론 Zustand/Jotai에서는 TanStack Query와 조합하는 게 일반적입니다.

---

## 번들 사이즈와 러닝 커브

| | **Zustand** | **Jotai** | **Redux Toolkit** |
|---|---|---|---|
| **번들 사이즈** (min+gzip) | ~1.1 kB | ~2.4 kB | ~11 kB (+ react-redux) |
| **Provider 필요** | 없음 | 선택적 | 필수 |
| **TypeScript** | 추론 우수 | 추론 우수 | 타입 설정 필요 |
| **러닝 커브** | 낮음 | 낮음 | 중간 |
| **DevTools** | 미들웨어 추가 | jotai-devtools | 내장 (시간 여행) |
| **React 외부 사용** | 가능 | React 전용 | 가능 |

Zustand와 Jotai는 "10분이면 시작할 수 있다"는 공통점이 있습니다.  
Redux는 Flux 패턴, Slice, dispatch 같은 개념을 이해해야 하지만, Redux Toolkit이 보일러플레이트를 크게 줄여준 덕분에 예전만큼 진입 장벽이 높지는 않습니다.

<aside data-type="info">
**번들 사이즈가 중요한 이유**

블로그처럼 콘텐츠 중심의 정적 사이트에서는 상태 관리 라이브러리의 번들 사이즈가 Lighthouse 점수에 직접적인 영향을 줍니다. 간단한 상태 관리가 필요하다면 가벼운 선택이 합리적입니다.
</aside>

---

## 언제 무엇을 선택할까

### Zustand를 선택하면 좋은 경우

- **중소규모 프로젝트**에서 빠르게 전역 상태를 설정하고 싶을 때
- Store 하나로 관련 상태와 액션을 **직관적으로 묶고** 싶을 때
- React 외부(vanilla JS, 테스트)에서도 상태에 접근해야 할 때
- Provider 없이 깔끔한 구조를 원할 때

### Jotai를 선택하면 좋은 경우

- 상태 간 **의존 관계가 복잡**하고, 파생 상태가 많을 때
- 컴포넌트별로 **세밀한 리렌더링 최적화**가 필요할 때
- `useState`처럼 가볍게 시작하되, 전역으로 확장하고 싶을 때
- 폼이나 필터처럼 **독립적인 상태 조각**이 많은 UI일 때

### Redux Toolkit을 선택하면 좋은 경우

- **대규모 팀**에서 일관된 상태 관리 패턴이 필요할 때
- **모든 상태 변경을 추적**하고 디버깅이 중요할 때
- RTK Query로 서버 상태까지 **하나의 생태계**에서 관리하고 싶을 때
- 복잡한 비동기 흐름(saga, thunk)을 체계적으로 다뤄야 할 때

---

## 혼합 사용도 괜찮다

최근 트렌드를 보면, 하나만 고집하는 프로젝트보다 **적재적소에 섞어 쓰는** 프로젝트가 늘고 있습니다.

```
전역 상태 (인증, 테마)     → Zustand
UI 로컬 상태 (모달, 폼)    → Jotai
서버 상태 (API 캐싱)       → TanStack Query
```

저도 이전 프로젝트에서 Zustand로 전역 상태를 관리하면서, TanStack Query로 서버 상태를 분리했습니다. 상태의 성격에 따라 도구를 나누면 각 라이브러리의 장점을 최대한 활용할 수 있습니다.

> **Zustand는 "편의성", Jotai는 "정밀함", Redux는 "안정감"** 에 방점이 찍혀 있습니다.

라이브러리를 고를 때마다 느끼는 건, 결국 "왜 이걸 쓰는가"에 대한 답이 명확해야 한다는 점입니다.  
프로젝트의 성격과 맞지 않는 도구는 아무리 좋아도 짐이 됩니다. 근거 없이 익숙한 걸 고르기보다, 지금 이 프로젝트에 왜 이 선택이 맞는지 설명할 수 있는 게 더 중요하다고 생각합니다.

---

## 참고 자료

- [Zustand Documentation](https://zustand.docs.pmnd.rs/)
- [Jotai Documentation](https://jotai.org/)
- [Redux Toolkit Documentation](https://redux-toolkit.js.org/)
- [Announcing Zustand v5 | Poimandres](https://pmnd.rs/blog/announcing-zustand-v5)
- [State Management in 2026: Redux, Context API, and Modern Patterns](https://www.nucamp.co/blog/state-management-in-2026-redux-context-api-and-modern-patterns)
- [Zustand vs. Redux Toolkit vs. Jotai | Better Stack](https://betterstack.com/community/guides/scaling-nodejs/zustand-vs-redux-toolkit-vs-jotai/)
