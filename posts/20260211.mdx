---
title: "React Element 참조로 이해하는 리렌더링"
description: "React.memo를 파고 들어가니 Element 참조라는 개념이 나왔습니다."
date: "2026-02-11"
slug: "20260211"
category: "Frontend"
tag: "React, Rendering, Performance"
published: true
---


`React.memo`를 제대로 이해하고 싶었습니다.  
어디에 붙여야 하고, 왜 어떤 경우에는 안 먹히는지.

그런데 파고 들어가다 보니 memo보다 먼저 알아야 할 게 있었습니다.  
React가 리렌더링 여부를 판단하는 기준, 즉 **Element 참조**라는 개념입니다.  
이걸 이해하고 나니 memo뿐 아니라 children 패턴, Context 구독까지 정리가 됐습니다.

---

## React Element는 그냥 객체입니다.

JSX를 쓰면 React는 내부적으로 평범한 JavaScript 객체를 만듭니다.

```tsx
<Page title="home" />

// 실제로는 이렇게 변환됩니다.
React.createElement(Page, { title: "home" })

// 결과는 JS 객체
{
  type: Page,
  props: { title: "home" },
  key: null,
  // ...
}
```

**컴포넌트가 리렌더링된다** 는 것은 곧 **이 함수가 다시 호출되어 새 객체가 만들어진다** 는 뜻입니다.   
그리고 React는 이전 Element와 새 Element의 **참조** 를 비교합니다.  
이걸 Reconciliation(재조정)이라고 하는데, 판단 기준은 놀라울 정도로 단순합니다.

```
이전 Element === 새 Element (같은 참조) → 서브트리 스킵
이전 Element !== 새 Element (다른 참조) → 리렌더링
```

참조가 같으면 React는 해당 컴포넌트뿐 아니라 **서브트리 전체의 렌더링을 건너뜁니다.**  
React 소스 코드에서는 이 경로를 `bailoutOnAlreadyFinishedWork`라는 함수로 처리합니다.

> "If the children are the same, we can skip the work."
> — [React 소스 코드, ReactFiberBeginWork.js](https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberBeginWork.js)

이 원리를 이해하면 Context 리렌더링 문제가 명쾌하게 풀립니다.

---

## children 패턴 vs 직접 렌더링

이 참조 비교가 실제로 어떤 차이를 만드는지, 두 가지 구조를 비교해보겠습니다.

### children 패턴: 왜 리렌더링을 막는가.

```tsx
function App() {
  return (
    <ThemeProvider>
      <Page />
    </ThemeProvider>
  );
}

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  return <ThemeContext value={theme}>{children}</ThemeContext>;
}
```

<aside data-type="info">
React 19부터는 `<Context.Provider>`가 deprecated되어 `<ThemeContext value={...}>`로 직접 쓸 수 있습니다.
</aside>

이 참조 비교가 실제로 어떤 차이를 만드는지, 두 가지 구조를 비교해보겠습니다.

**children 패턴** 에서는 `<Page />`를 App이 만들었고, App은 리렌더링되지 않았으니 그 참조가 그대로 유지됩니다. React는 "이전이랑 같네?" 하고 서브트리를 통째로 건너뜁니다.

**직접 렌더링** 에서는 ThemeProvider가 리렌더링될 때마다 `<Page />`를 새로 생성합니다. 같은 `<Page />`지만 **매번 새 객체** 이기 때문에 React는 다른 것으로 판단합니다.

핵심은 `<Page />`를 **누가 만들었느냐** 입니다.

### 직접 렌더링 코드

```tsx
function ThemeProvider() {
  const [theme, setTheme] = useState('light');
  return (
    <ThemeContext value={theme}>
      <Page />
    </ThemeContext>
  );
}
```

---

## 그러면 memo를 붙이면 되지 않나요?

children 패턴을 모르는 상태에서 가장 먼저 떠오르는 해결책이 `React.memo`입니다. memo는 리렌더링 판단 과정에 한 단계를 추가합니다.

```
일반:  참조가 다름 → 바로 리렌더링
memo: 참조가 다름 → props를 얕은 비교 → 같으면 스킵, 다르면 리렌더링
```

```tsx
const Page = React.memo(({ title }) => {
  return <div>{title}</div>;
});
```

직접 렌더링 구조에서도 props가 안 바뀌면 memo가 리렌더링을 막아줄 수 있습니다.

**하지만 한 가지 예외가 있습니다.**

---

## Context 구독은 다른 경로를 탑니다

`useContext`로 Context를 구독 중인 컴포넌트는 memo를 붙여도 value가 변경되면 리렌더링됩니다.

```tsx
const MemoizedChild = React.memo(function Child() {
  const theme = useContext(ThemeContext); // 구독 중
  return <div>{theme}</div>;
});

// theme이 바뀌면 memo에도 불구하고 리렌더링됨
```

일반적인 리렌더링은 부모 → 자식으로 전파되기 때문에, 그 경로 위에 있는 memo가 방어할 수 있습니다.  
하지만 Context는 이 경로를 타지 않습니다.

Context value가 변경되면 React는 **Fiber 트리를 순회하며 해당 Context를 구독하는 컴포넌트를 직접 찾아서 dirty로 마킹**합니다.  
부모-자식 렌더링 경로를 거치지 않고, 구독자를 직접 리렌더링 대상에 등록하는 방식입니다.  
memo는 부모로부터의 리렌더링 전파를 막는 장치이므로, 이 경로에서는 개입할 수 없습니다.

```
일반 리렌더링: 부모 리렌더링 → 자식 Element 재생성 → memo로 방어 가능
Context 리렌더링: value 변경 → Fiber 순회 → 구독자 직접 dirty 마킹 → memo 무시
```

그리고 이 value 변경 여부를 판단할 때 React는 `Object.is`를 사용합니다.  
매 렌더링마다 새 객체를 value로 넘기면 `Object.is`가 `false`를 반환하고, 모든 구독자가 리렌더링됩니다. 이것이 뒤에서 다룰 `useMemo`로 참조를 안정시켜야 하는 이유입니다.

<aside data-type="info">
`Object.is`는 `===`과 거의 동일하지만 두 가지 경우에 다르게 동작합니다.  
`Object.is(NaN, NaN)`은 `true`이고(===는 false), `Object.is(+0, -0)`은 `false`입니다(===는 true).  
실무에서 이 차이가 문제가 되는 경우는 거의 없지만, Context value 비교가 `===`이 아니라 `Object.is`라는 점은 알아두면 좋습니다.
</aside>

---

## 정리

| 상황 | 리렌더링? | memo 효과? |
|---|---|---|
| children 패턴으로 전달 | ❌ 안 됨 | 필요 없음 |
| Provider 내부에서 직접 렌더링 (context 미사용) | ✅ 됨 | ✅ 막을 수 있음 |
| useContext로 구독 중 + value 변경 | ✅ 됨 | ❌ 못 막음 |

### 직접 체험해보기

위 세 가지 시나리오의 차이를 직접 확인해보세요. 각 패널의 테마 변경 버튼을 누르면 Provider와 Page의 렌더 횟수가 어떻게 달라지는지 관찰할 수 있습니다.

<ContextRerenderDemo />

<aside data-type="info">
**이렇게 확인해보세요.**

1. 세 패널의 테마 변경 버튼을 각각 여러 번 눌러보세요.
2. **children 패턴**: Provider 렌더 횟수는 올라가지만 Page는 1회에서 멈춥니다.
3. **직접 렌더링 + memo**: Provider가 리렌더링돼도 memo가 Page를 방어합니다.
4. **memo + useContext**: memo가 있어도 Context 구독 때문에 Page도 함께 리렌더링됩니다.
</aside>

---

## 실무에서의 Context 성능 최적화

원리를 이해했으니, 실무에서 적용할 수 있는 전략을 정리해보겠습니다.

### 1. Provider는 항상 children 패턴으로

```tsx
// ✅
function App() {
  return (
    <ThemeProvider>
      <Page />
    </ThemeProvider>
  );
}

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  return <ThemeContext value={theme}>{children}</ThemeContext>;
}
```

### 2. 변경 빈도가 다른 값은 Context를 분리

```tsx
// ❌ theme이 바뀌면 setTheme만 쓰는 컴포넌트도 리렌더링
const ThemeContext = createContext({ theme: 'light', setTheme: () => {} });

// ✅ 분리하면 setTheme만 쓰는 컴포넌트는 리렌더링 안 됨
const ThemeValueContext = createContext('light');
const ThemeSetterContext = createContext(() => {});
```

값(state)과 갱신 함수(setter)를 분리하는 것이 가장 흔한 패턴입니다.  
setter는 `useState`가 반환하는 함수이므로 참조가 안정적이고, setter만 구독하는 컴포넌트는 value가 바뀌어도 리렌더링되지 않습니다.

### 3. value에 객체를 넘길 때는 useMemo로 참조를 안정시킨다

```tsx
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  // ❌ 매 렌더링마다 새 객체 → Object.is가 false → 모든 구독자 리렌더링
  // return <ThemeContext value={{ theme, setTheme }}>{children}</ThemeContext>;

  // ✅ theme이 바뀔 때만 새 객체
  const value = useMemo(() => ({ theme, setTheme }), [theme]);
  return <ThemeContext value={value}>{children}</ThemeContext>;
}
```

<aside data-type="info">
Fiber 트리 순회 시 React는 `Object.is(이전 value, 새 value)`로 변경 여부를 판단합니다.  
`useMemo`로 참조를 안정시키면 의존성이 바뀌지 않는 한 같은 객체가 반환되므로, 불필요한 구독자 리렌더링을 방지할 수 있습니다.
다만 `useMemo` 자체도 의존성 비교 비용이 있으므로, 원시값 하나만 넘기는 경우에는 굳이 감쌀 필요가 없습니다.
</aside>

---

## 마치며

memo 하나 알려고 시작했는데, 결국 Element 참조, children 패턴, Fiber 순회까지 오게 됐습니다.

돌아보면 결국 하나입니다. React는 **참조가 같으면 건너뛰고, 다르면 다시 그립니다.** memo도, children 패턴도, Context 최적화도 전부 이 규칙 위에 있습니다.

"memo를 어디에 붙이지?"보다 "이 Element의 참조가 유지되고 있는가?"를 먼저 묻게 된 게 이번에 얻은 가장 큰 수확입니다.


---


## 참고 자료

- [Before You memo()](https://overreacted.io/before-you-memo/) — Dan Abramov
- [createContext - React 공식 문서](https://react.dev/reference/react/createContext)
- [A (Mostly) Complete Guide to React Rendering Behavior](https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/) — Mark Erikson
