---
title: "Nextjs의 실험 기능 맛보기 - PPR 전략"
date: "2025-10-24"
slug: "20251024"
tag: "NextJs"
category: "Frontend"
description: "Nextjs 앞으로 나올 기능중 하나인 PPR 전략을 간략하게 소개합니다."
---

> *Partial Prerendering은* **experimental***기능이며 변경될 수 있습니다!*   
이 기능은 `next@canary` 에만 적용이 되어있습니다.
> 

Partial Prerendering (PPR)은 동일한 경로에서 정적 렌더링과 동적 렌더링의 이점을 결합하는 렌더링 전략입니다.  
이 전략을 이용하게 되면 다음과 같은 이점을 취할 수 있습니다.

1. 정적 부분은 즉시 HTML로 제공
2. 동적 부분은 백그라운드에서 렌더링
3. 사용자는 매우 빠르게 페이지 보임
4. 콘텐츠는 스트리밍으로 점진적 표시

<aside data-type="note">
PPR은 한 페이지에 정적 콘텐츠와 동적 콘텐츠가 혼합 되어있을 때 사용하는 것이 가장 효율적입니다.  
즉, **완전 정적인 페이지를 다루거나 완전 동적인 페이지에는 사용하지 않아도 됩니다.**
</aside>

### 1. next.config.ts 에서 먼저 적용

```tsx
// next.config.ts
import type { NextConfig } from 'next'

const nextConfig: NextConfig = {
  experimental: {
    ppr: 'incremental',
  },
  ...
}

export default nextConfig
```

### 2. 필요한 페이지에 PPR 활성화

```tsx
// /src/app/blog/page.tsx
export const experimental_ppr = true;

const MainPage = () => {
  return (
    <PostList />
  );
};

export default MainPage;
```

### 3. `Suspense`로 동적 부분 감싸기

```tsx
import { Suspense } from "react";
import PostList from "@/widgets/post/ui/PostList";

export const experimental_ppr = true;

const MainPage = () => {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <PostList />
    </Suspense>
  );
};

export default MainPage;
```

### 동작 흐름

빌드 시간. 
Header (정적) → HTML 미리 생성   
Footer (정적) → HTML 미리 생성  
Sidebar (Suspense) → 스킵  
PostList (Suspense) → 스킵  

사용자에게는 [Sidebar 로딩...] 및 [PostList 로딩…] 이 보여지게 됩니다.  
각각 비동기적으로 동작하면서, 동시에 병렬로 진행되기 때문에 둘 중 하나라도 준비가 끝나면 준비가 다 된 컴포넌트는 사용자에게 바로 보여집니다.  
사용자가 느끼기엔 점진적으로 준비가 되어 사이트를 보여준다는 느낌을 줄 수 있습니다.

<aside data-type="warning">
### **무분별하게 PPR을 사용하지마세요!**

*"PPR enables opt-in to prerendering at the page level. This tells Next.js to prerender a static shell for the page, while deferring dynamic components wrapped in `<Suspense>` until request time."*
</aside>

**1. 빌드 시간 증가**

기존 빌드로 진행하게 되면 정적 생성 한번만 하기에 30초의 빌드시간을 갖고 끝나지만,

모든 페이지에 PPR 을 적용하게 되면 각 페이지마다 정적 셸을 생성하게 됩니다.  
이는 Suspense 경계를 분석하고 동적 부분 매핑까지 동작을 하기때문에 빌드시간이 약 4배정도 늘어날 수 있습니다.

 **2. 불필요한 스켈레톤 표시**

정적인 부분에 굳이 `Suspense` 를 넣고 스켈레톤 UI 추가를 하는 것은 오히려 사용자 경험을 해칠 수 있습니다.

**3. Suspense 구조 복잡화**

```tsx
export const experimental_ppr = true

export default function Page() {
  return (
    <div>
      <Suspense fallback={<Skeleton1 />}>
        <Component1 />
      </Suspense>
      
      <Suspense fallback={<Skeleton2 />}>
        <Component2 />
      </Suspense>
      
      <Suspense fallback={<Skeleton3 />}>
        <Component3 />
      </Suspense>
      
      <Suspense fallback={<Skeleton4 />}>
        <Component4 />
      </Suspense>
      
      ...
    </div>
  )
}
```

예시 코드로 보여지듯이 코드 가독성이 낮아지기에 그만큼 유지보수가 어려워집니다.  
에러처리 및 디버깅에도 어려움이 따르겠지요.

 **4. 네트워크 요청 증가**

- **SEO 문제**  
PPR 사용하게 되면 메타 데이터는 정적 셸 생성 중에는 안 보입니다.  
따라서, SEO 점수가 떨어질 위험이 있습니다.

# 정리하자면..


<aside data-type='success'>
### PPR을 사용해야 할 때?

정적 콘텐츠와 동적 콘텐츠가 혼합되어 있을 때 PPR의 가치가 가장 높습니다.
</aside>

**1. 정적 부분이 크고 명확할 때**. 
예시: Header, Footer, Navigation 등

정적 콘텐츠를 먼저 렌더링하고 동적 부분은 나중에 로드됩니다.  
사용자가 즉시 무언가를 볼 수 있어서 로딩 시간을 덜 느낍니다.

**2. 동적 부분 로드 시간이 길 때**  
예시: API 응답이 1초 이상 걸리는 경우

느린 데이터 요청이 있어도 페이지 일부를 먼저 보여줄 수 있습니다.  
헤더와 같은 정적 부분만이라도 빨리 표시되면 사용자 경험이 훨씬 좋습니다.

**3. 사용자가 즉시 봐야 할 콘텐츠일 때**

예시: 주요 정보, 상단 콘텐츠 등

우선순위 높은 정적 영역을 먼저 렌더링할 수 있습니다. 사용자는 중요한 정보부터 보게 됩니다.


<aside data-type='warning'>
### PPR을 피해야 할 때?

이 경우들에는 PPR의 이점이 없거나 오버헤드가 더 큽니다.
</aside>
**1. 완전 정적 페이지일 때**

예시: 문서, 정책 페이지 등

모든 콘텐츠가 빌드 시 결정되므로 PPR이 불필요합니다. 어차피 빠르기 때문에 복잡하게 할 이유가 없습니다.

**2. 완전 동적 페이지일 때**

예시: API 기반 대시보드 등

모든 부분이 데이터에 의존하므로 정적 부분이 없습니다. 정적 부분이 없으면 PPR의 목적 자체가 의미가 없습니다.

**3. 동적 부분이 매우 빠를 때**

예시: 100ms 이내 응답

PPR 오버헤드가 얻는 이득보다 더 클 수 있습니다. 빠르면 무리해서 복잡하게 할 필요 없습니다.

**4. Waterfalling 위험이 있을 때**

예시: 여러 API가 순차적으로 의존

PPR 적용 시 병목이 발생할 수 있습니다. API 1 → API 2 → API 3 이렇게 순차적으로 필요하면 오히려 시간이 더 걸릴 수 있습니다.

---

현재 PPR은 `next@canary` 로만 확인할 수 있는 **실험 단계의 기능**이지만, Next.js 팀이 매우 적극적으로 개발하고 있습니다.

PPR이 공식적으로 출시되면, 더 자세한 실전 가이드와 실제 프로젝트 적용 사례, 성능 비교 분석 등을 통해 깊이 있게 파고들어보겠습니다. 


---

[공식문서](https://nextjs.org/docs/app/getting-started/cache-components#cache-components)